From 0234362753d6f9067f3498845e0bf5666d897a15 Mon Sep 17 00:00:00 2001
From: jingjin <jingjin666@gmail.com>
Date: Thu, 31 Dec 2020 17:40:45 +0800
Subject: [PATCH] ADD JKF.

---
 ArduCopter/ArduCopter.cpp          |  37 +++++
 ArduCopter/Copter.h                |   4 +
 ArduCopter/system.cpp              |   2 +
 libraries/AP_NavEKF2/AP_NavJKF.cpp | 293 +++++++++++++++++++++++++++++++++++++
 libraries/AP_NavEKF2/AP_NavJKF.h   |  30 ++++
 libraries/DataFlash/DataFlash.h    |   2 +
 libraries/DataFlash/LogFile.cpp    |  69 +++++++++
 libraries/DataFlash/LogStructure.h |  42 +++++-
 8 files changed, 478 insertions(+), 1 deletion(-)
 create mode 100644 libraries/AP_NavEKF2/AP_NavJKF.cpp
 create mode 100644 libraries/AP_NavEKF2/AP_NavJKF.h

diff --git a/ArduCopter/ArduCopter.cpp b/ArduCopter/ArduCopter.cpp
index 30ef7cd..0f332d8 100644
--- a/ArduCopter/ArduCopter.cpp
+++ b/ArduCopter/ArduCopter.cpp
@@ -145,6 +145,7 @@ const AP_Scheduler::Task Copter::scheduler_tasks[] = {
 #endif
 #if LOGGING_ENABLED == ENABLED
     SCHED_TASK(ten_hz_logging_loop,   10,    350),
+    SCHED_TASK(test_hz_logging,      400,    150),
     SCHED_TASK(twentyfive_hz_logging, 25,    110),
     SCHED_TASK_CLASS(DataFlash_Class,      &copter.DataFlash,           periodic_tasks, 400, 300),
 #endif
@@ -363,6 +364,42 @@ void Copter::ten_hz_logging_loop()
 #endif
 }
 
+void Copter::test_hz_logging()
+{
+#if 1
+    static uint32_t last_time = 0;
+    float dt = 0;
+    if(last_time == 0)
+        dt = 0;
+    else
+        dt = AP_HAL::millis() - last_time;
+    last_time = AP_HAL::millis();
+    dt *= 0.001;
+
+    Vector3f acc_data = ins.get_accel();
+
+    Quaternion quat;
+    ahrs.get_secondary_quaternion(quat);
+
+    Matrix3f dcm;
+    quat.rotation_matrix(dcm);
+    //Vector3f acc_data_ned = dcm*acc_data;
+    //JKF.sys_predict(dt, acc_data_ned);
+    JKF.sys_predict(dt, acc_data, dcm);
+
+    Vector3f gps_data_ned = gps.velocity();
+    //JKF.sys_update(gps_data_ned);
+    JKF.sys_update(gps_data_ned, dcm);
+
+    Vector3f vel;
+    JKF.getVelocity(vel);
+
+    DataFlash.Log_Write_JKF(vel);
+#else
+    DataFlash.Log_Write_JKF_Sensor();
+#endif
+}
+
 // twentyfive_hz_logging - should be run at 25hz
 void Copter::twentyfive_hz_logging()
 {
diff --git a/ArduCopter/Copter.h b/ArduCopter/Copter.h
index cedcde3..683804a 100644
--- a/ArduCopter/Copter.h
+++ b/ArduCopter/Copter.h
@@ -46,6 +46,7 @@
 #include <AP_AHRS/AP_AHRS.h>
 #include <AP_NavEKF2/AP_NavEKF2.h>
 #include <AP_NavEKF3/AP_NavEKF3.h>
+#include <AP_NavEKF2/AP_NavJKF.h>
 #include <AP_Mission/AP_Mission.h>     // Mission command library
 #include <AC_PID/AC_P.h>               // P library
 #include <AC_PID/AC_PID.h>             // PID library
@@ -257,6 +258,8 @@ private:
     NavEKF3 EKF3{&ahrs, rangefinder};
     AP_AHRS_NavEKF ahrs{EKF2, EKF3, AP_AHRS_NavEKF::FLAG_ALWAYS_USE_EKF};
 
+    AP_NavJKF JKF{&ahrs};
+
 #if CONFIG_HAL_BOARD == HAL_BOARD_SITL
     SITL::SITL sitl;
 #endif
@@ -669,6 +672,7 @@ private:
     void update_batt_compass(void);
     void fourhundred_hz_logging();
     void ten_hz_logging_loop();
+    void test_hz_logging();
     void twentyfive_hz_logging();
     void three_hz_loop();
     void one_hz_loop();
diff --git a/ArduCopter/system.cpp b/ArduCopter/system.cpp
index f0fb539..9c14583 100644
--- a/ArduCopter/system.cpp
+++ b/ArduCopter/system.cpp
@@ -307,6 +307,8 @@ void Copter::startup_INS_ground()
 
     // reset ahrs including gyro bias
     ahrs.reset();
+
+    JKF.sys_init();
 }
 
 // position_ok - returns true if the horizontal absolute position is ok and home position is set
diff --git a/libraries/AP_NavEKF2/AP_NavJKF.cpp b/libraries/AP_NavEKF2/AP_NavJKF.cpp
new file mode 100644
index 0000000..5b30546
--- /dev/null
+++ b/libraries/AP_NavEKF2/AP_NavJKF.cpp
@@ -0,0 +1,293 @@
+#include "AP_NavJKF.h"
+
+AP_NavJKF::AP_NavJKF(const AP_AHRS *ahrs) : 
+    _ahrs(ahrs)
+{
+
+}
+
+
+AP_NavJKF::~AP_NavJKF()
+{
+    memset(X, 0, sizeof(X));
+    memset(P, 0, sizeof(P));
+    memset(Q, 0, sizeof(Q));
+    memset(R, 0, sizeof(R));
+}
+
+//过程噪声
+#define VELNE_P_NSE_DEFAULT     1e-8f
+#define VELD_P_NSE_DEFAULT     1e-8f
+
+#define ABIAS_NE_P_NSE_DEFAULT     1e-8f
+#define ABIAS_D_P_NSE_DEFAULT     1e-8f
+
+//测量噪声
+#define VELNE_M_NSE_DEFAULT     0.5f
+#define VELD_M_NSE_DEFAULT      0.7f
+
+void AP_NavJKF::sys_init()
+{
+    printf("NavJKF:: init\n");
+
+    // 系统状态初始化
+    X[0] = 0;
+    X[1] = 0;
+    X[2] = 0;
+    X[3] = 0.01;
+    X[4] = 0.01;
+    X[5] = 0.01;
+
+    // 协方差矩阵初始化
+    P[0][0] = VELNE_M_NSE_DEFAULT;
+    P[1][1] = VELNE_M_NSE_DEFAULT;
+    P[2][2] = VELD_M_NSE_DEFAULT;
+    P[3][3] = 0.01;
+    P[4][4] = 0.01;
+    P[5][5] = 0.01;
+
+    // 过程噪声矩阵初始化
+    // velocity variance
+    Q[0][0] = VELNE_P_NSE_DEFAULT;
+    Q[1][1] = VELNE_P_NSE_DEFAULT;
+    Q[2][2] = VELD_P_NSE_DEFAULT;
+    // acc bias variance
+    Q[3][3] = ABIAS_NE_P_NSE_DEFAULT;
+    Q[4][4] = ABIAS_NE_P_NSE_DEFAULT;
+    Q[5][5] = ABIAS_D_P_NSE_DEFAULT;
+
+    // 观测噪声矩阵初始化
+    // measurement noise
+    R[0][0]= VELNE_M_NSE_DEFAULT;
+    R[1][1]= VELNE_M_NSE_DEFAULT;
+    R[2][2]= VELD_M_NSE_DEFAULT; 
+}
+
+#define earthRate 0.000072921f // earth rotation rate (rad/sec)
+
+// calculate the NED earth spin vector in rad/sec
+void AP_NavJKF::calcEarthRateNED(Vector3f &omega, int32_t latitude) const
+{
+    float lat_rad = radians(latitude*1.0e-7f);
+    omega.x  = earthRate*cosf(lat_rad);
+    omega.y  = 0;
+    omega.z  = -earthRate*sinf(lat_rad);
+}
+
+void AP_NavJKF::sys_predict(float delta_t, Vector3f &acc, Matrix3f &dcm)
+{
+    float velX = X[0];
+    float velY = X[1];
+    float velZ = X[2];
+    float a_bx = X[3];
+    float a_by = X[4];
+    float a_bz = X[5];
+    float acc_x = acc.x;
+    float acc_y = acc.y;
+    float acc_z = acc.z;
+
+    Vector3f acc_data = {acc_x-a_bx, acc_y-a_by, acc_z-a_bz};
+    Vector3f acc_truth = dcm*acc_data;
+
+    // kf_state_prediction.cpp
+    float X_next[6];
+    #if 0
+    X_next[0] = velX + delta_t*(-a_bx + acc_x);
+    X_next[1] = velY + delta_t*(-a_by + acc_y);
+    X_next[2] = velZ + delta_t*(-a_bz + GRAVITY_MSS + acc_z);
+    #else
+    X_next[0] = velX + delta_t*(acc_truth.x);
+    X_next[1] = velY + delta_t*(acc_truth.y);
+    X_next[2] = velZ + delta_t*(acc_truth.z + GRAVITY_MSS);
+    #endif
+    X_next[3] = a_bx;
+    X_next[4] = a_by;
+    X_next[5] = a_bz;
+
+    // kf_covariance_prediction.cpp
+    float P_item0 = P[0][3] - P[3][3]*delta_t;
+    float P_item1 = -P[3][4]*delta_t;
+    float P_item2 = P[0][4] + P_item1;
+    float P_item3 = -P[3][5]*delta_t;
+    float P_item4 = P[0][5] + P_item3;
+    float P_item5 = P[1][3] + P_item1;
+    float P_item6 = P[1][4] - P[4][4]*delta_t;
+    float P_item7 = -P[4][5]*delta_t;
+    float P_item8 = P[1][5] + P_item7;
+    float P_item9 = P[2][3] + P_item3;
+    float P_item10 = P[2][4] + P_item7;
+    float P_item11 = P[2][5] - P[5][5]*delta_t;
+    
+    
+    float P_next[6][6];
+    P_next[0][0] = P[0][0] - P[0][3]*delta_t - P_item0*delta_t + Q[0][0]*delta_t;
+    P_next[1][0] = P[0][1] - P[0][4]*delta_t - P_item5*delta_t + Q[1][0]*delta_t;
+    P_next[2][0] = P[0][2] - P[0][5]*delta_t - P_item9*delta_t + Q[2][0]*delta_t;
+    P_next[3][0] = P_item0 + Q[3][0]*delta_t;
+    P_next[4][0] = P_item2 + Q[4][0]*delta_t;
+    P_next[5][0] = P_item4 + Q[5][0]*delta_t;
+    P_next[0][1] = P[0][1] - P[1][3]*delta_t - P_item2*delta_t + Q[0][1]*delta_t;
+    P_next[1][1] = P[1][1] - P[1][4]*delta_t - P_item6*delta_t + Q[1][1]*delta_t;
+    P_next[2][1] = P[1][2] - P[1][5]*delta_t - P_item10*delta_t + Q[2][1]*delta_t;
+    P_next[3][1] = P_item5 + Q[3][1]*delta_t;
+    P_next[4][1] = P_item6 + Q[4][1]*delta_t;
+    P_next[5][1] = P_item8 + Q[5][1]*delta_t;
+    P_next[0][2] = P[0][2] - P[2][3]*delta_t - P_item4*delta_t + Q[0][2]*delta_t;
+    P_next[1][2] = P[1][2] - P[2][4]*delta_t - P_item8*delta_t + Q[1][2]*delta_t;
+    P_next[2][2] = P[2][2] - P[2][5]*delta_t - P_item11*delta_t + Q[2][2]*delta_t;
+    P_next[3][2] = P_item9 + Q[3][2]*delta_t;
+    P_next[4][2] = P_item10 + Q[4][2]*delta_t;
+    P_next[5][2] = P_item11 + Q[5][2]*delta_t;
+    P_next[0][3] = P_item0 + Q[0][3]*delta_t;
+    P_next[1][3] = P_item5 + Q[1][3]*delta_t;
+    P_next[2][3] = P_item9 + Q[2][3]*delta_t;
+    P_next[3][3] = P[3][3] + Q[3][3]*delta_t;
+    P_next[4][3] = P[3][4] + Q[4][3]*delta_t;
+    P_next[5][3] = P[3][5] + Q[5][3]*delta_t;
+    P_next[0][4] = P_item2 + Q[0][4]*delta_t;
+    P_next[1][4] = P_item6 + Q[1][4]*delta_t;
+    P_next[2][4] = P_item10 + Q[2][4]*delta_t;
+    P_next[3][4] = P[3][4] + Q[3][4]*delta_t;
+    P_next[4][4] = P[4][4] + Q[4][4]*delta_t;
+    P_next[5][4] = P[4][5] + Q[5][4]*delta_t;
+    P_next[0][5] = P_item4 + Q[0][5]*delta_t;
+    P_next[1][5] = P_item8 + Q[1][5]*delta_t;
+    P_next[2][5] = P_item11 + Q[2][5]*delta_t;
+    P_next[3][5] = P[3][5] + Q[3][5]*delta_t;
+    P_next[4][5] = P[4][5] + Q[4][5]*delta_t;
+    P_next[5][5] = P[5][5] + Q[5][5]*delta_t;
+    
+    memcpy(X, X_next, sizeof(X_next));
+    memcpy(P, P_next, sizeof(P_next));
+}
+void AP_NavJKF::sys_update(Vector3f &gps, Matrix3f &dcm){
+    float velX = X[0];
+    float velY = X[1];
+    float velZ = X[2];
+    float a_bx = X[3];
+    float a_by = X[4];
+    float a_bz = X[5];
+    float gpsVelX = gps.x;
+    float gpsVelY = gps.y;
+    float gpsVelZ = gps.z;
+    float R_meas_x = R[0][0];
+    float R_meas_y = R[1][1];
+    float R_meas_z = R[2][2];
+    
+    // kf_SP.cpp
+    float SP[3][3];
+    SP[0][0] = P[0][0] + R_meas_x;
+    SP[1][0] = P[0][1];
+    SP[2][0] = P[0][2];
+    SP[0][1] = P[0][1];
+    SP[1][1] = P[1][1] + R_meas_y;
+    SP[2][1] = P[1][2];
+    SP[0][2] = P[0][2];
+    SP[1][2] = P[1][2];
+    SP[2][2] = P[2][2] + R_meas_z;
+    
+    // kf_SPINV.cpp
+    float SPINV_item0 = SP[1][1]*SP[2][2];
+    float SPINV_item1 = SP[1][2]*SP[2][1];
+    float SPINV_item2 = SP[0][1]*SP[1][2];
+    float SPINV_item3 = SP[0][2]*SP[2][1];
+    float SPINV_item4 = SP[0][1]*SP[2][2];
+    float SPINV_item5 = SP[0][2]*SP[1][1];
+    float SPINV_item6 = 1.0F/(SPINV_item0*SP[0][0] - SPINV_item1*SP[0][0] + SPINV_item2*SP[2][0] + SPINV_item3*SP[1][0] - SPINV_item4*SP[1][0] - SPINV_item5*SP[2][0]);
+    
+    
+    float SPINV[3][3];
+    SPINV[0][0] = SPINV_item6*(SPINV_item0 - SPINV_item1);
+    SPINV[1][0] = -SPINV_item6*(SP[1][0]*SP[2][2] - SP[1][2]*SP[2][0]);
+    SPINV[2][0] = SPINV_item6*(SP[1][0]*SP[2][1] - SP[1][1]*SP[2][0]);
+    SPINV[0][1] = -SPINV_item6*(-SPINV_item3 + SPINV_item4);
+    SPINV[1][1] = SPINV_item6*(SP[0][0]*SP[2][2] - SP[0][2]*SP[2][0]);
+    SPINV[2][1] = -SPINV_item6*(SP[0][0]*SP[2][1] - SP[0][1]*SP[2][0]);
+    SPINV[0][2] = SPINV_item6*(SPINV_item2 - SPINV_item5);
+    SPINV[1][2] = -SPINV_item6*(SP[0][0]*SP[1][2] - SP[0][2]*SP[1][0]);
+    SPINV[2][2] = SPINV_item6*(SP[0][0]*SP[1][1] - SP[0][1]*SP[1][0]);
+
+    // kf_state_update.cpp
+    float X_new_item0 = velX - gpsVelX;
+    float X_new_item1 = velY - gpsVelY;
+    float X_new_item2 = velZ - gpsVelZ;
+    
+    
+    float X_new[6];
+    X_new[0] = -X_new_item0*(P[0][0]*SPINV[0][0] + P[0][1]*SPINV[1][0] + P[0][2]*SPINV[2][0]) - X_new_item1*(P[0][0]*SPINV[0][1] + P[0][1]*SPINV[1][1] + P[0][2]*SPINV[2][1]) - X_new_item2*(P[0][0]*SPINV[0][2] + P[0][1]*SPINV[1][2] + P[0][2]*SPINV[2][2]) + velX;
+    X_new[1] = -X_new_item0*(P[0][1]*SPINV[0][0] + P[1][1]*SPINV[1][0] + P[1][2]*SPINV[2][0]) - X_new_item1*(P[0][1]*SPINV[0][1] + P[1][1]*SPINV[1][1] + P[1][2]*SPINV[2][1]) - X_new_item2*(P[0][1]*SPINV[0][2] + P[1][1]*SPINV[1][2] + P[1][2]*SPINV[2][2]) + velY;
+    X_new[2] = -X_new_item0*(P[0][2]*SPINV[0][0] + P[1][2]*SPINV[1][0] + P[2][2]*SPINV[2][0]) - X_new_item1*(P[0][2]*SPINV[0][1] + P[1][2]*SPINV[1][1] + P[2][2]*SPINV[2][1]) - X_new_item2*(P[0][2]*SPINV[0][2] + P[1][2]*SPINV[1][2] + P[2][2]*SPINV[2][2]) + velZ;
+    X_new[3] = -X_new_item0*(P[0][3]*SPINV[0][0] + P[1][3]*SPINV[1][0] + P[2][3]*SPINV[2][0]) - X_new_item1*(P[0][3]*SPINV[0][1] + P[1][3]*SPINV[1][1] + P[2][3]*SPINV[2][1]) - X_new_item2*(P[0][3]*SPINV[0][2] + P[1][3]*SPINV[1][2] + P[2][3]*SPINV[2][2]) + a_bx;
+    X_new[4] = -X_new_item0*(P[0][4]*SPINV[0][0] + P[1][4]*SPINV[1][0] + P[2][4]*SPINV[2][0]) - X_new_item1*(P[0][4]*SPINV[0][1] + P[1][4]*SPINV[1][1] + P[2][4]*SPINV[2][1]) - X_new_item2*(P[0][4]*SPINV[0][2] + P[1][4]*SPINV[1][2] + P[2][4]*SPINV[2][2]) + a_by;
+    X_new[5] = -X_new_item0*(P[0][5]*SPINV[0][0] + P[1][5]*SPINV[1][0] + P[2][5]*SPINV[2][0]) - X_new_item1*(P[0][5]*SPINV[0][1] + P[1][5]*SPINV[1][1] + P[2][5]*SPINV[2][1]) - X_new_item2*(P[0][5]*SPINV[0][2] + P[1][5]*SPINV[1][2] + P[2][5]*SPINV[2][2]) + a_bz;
+
+    // kf_covariance_update.cpp
+    float P_new_item0 = P[0][0]*SPINV[0][1] + P[0][1]*SPINV[1][1] + P[0][2]*SPINV[2][1];
+    float P_new_item1 = P[0][0]*SPINV[0][2] + P[0][1]*SPINV[1][2] + P[0][2]*SPINV[2][2];
+    float P_new_item2 = P[0][0]*SPINV[0][0] + P[0][1]*SPINV[1][0] + P[0][2]*SPINV[2][0] - 1;
+    float P_new_item3 = P[0][1]*SPINV[0][0] + P[1][1]*SPINV[1][0] + P[1][2]*SPINV[2][0];
+    float P_new_item4 = P[0][1]*SPINV[0][2] + P[1][1]*SPINV[1][2] + P[1][2]*SPINV[2][2];
+    float P_new_item5 = P[0][1]*SPINV[0][1] + P[1][1]*SPINV[1][1] + P[1][2]*SPINV[2][1] - 1;
+    float P_new_item6 = P[0][2]*SPINV[0][0] + P[1][2]*SPINV[1][0] + P[2][2]*SPINV[2][0];
+    float P_new_item7 = P[0][2]*SPINV[0][1] + P[1][2]*SPINV[1][1] + P[2][2]*SPINV[2][1];
+    float P_new_item8 = P[0][2]*SPINV[0][2] + P[1][2]*SPINV[1][2] + P[2][2]*SPINV[2][2] - 1;
+    float P_new_item9 = P[0][3]*SPINV[0][0] + P[1][3]*SPINV[1][0] + P[2][3]*SPINV[2][0];
+    float P_new_item10 = P[0][3]*SPINV[0][1] + P[1][3]*SPINV[1][1] + P[2][3]*SPINV[2][1];
+    float P_new_item11 = P[0][3]*SPINV[0][2] + P[1][3]*SPINV[1][2] + P[2][3]*SPINV[2][2];
+    float P_new_item12 = P[0][4]*SPINV[0][0] + P[1][4]*SPINV[1][0] + P[2][4]*SPINV[2][0];
+    float P_new_item13 = P[0][4]*SPINV[0][1] + P[1][4]*SPINV[1][1] + P[2][4]*SPINV[2][1];
+    float P_new_item14 = P[0][4]*SPINV[0][2] + P[1][4]*SPINV[1][2] + P[2][4]*SPINV[2][2];
+    float P_new_item15 = P[0][5]*SPINV[0][0] + P[1][5]*SPINV[1][0] + P[2][5]*SPINV[2][0];
+    float P_new_item16 = P[0][5]*SPINV[0][1] + P[1][5]*SPINV[1][1] + P[2][5]*SPINV[2][1];
+    float P_new_item17 = P[0][5]*SPINV[0][2] + P[1][5]*SPINV[1][2] + P[2][5]*SPINV[2][2];
+    
+    
+    float P_new[6][6];
+    P_new[0][0] = -P[0][0]*P_new_item2 - P[0][1]*P_new_item0 - P[0][2]*P_new_item1;
+    P_new[1][0] = -P[0][0]*P_new_item3 - P[0][1]*P_new_item5 - P[0][2]*P_new_item4;
+    P_new[2][0] = -P[0][0]*P_new_item6 - P[0][1]*P_new_item7 - P[0][2]*P_new_item8;
+    P_new[3][0] = -P[0][0]*P_new_item9 - P[0][1]*P_new_item10 - P[0][2]*P_new_item11 + P[0][3];
+    P_new[4][0] = -P[0][0]*P_new_item12 - P[0][1]*P_new_item13 - P[0][2]*P_new_item14 + P[0][4];
+    P_new[5][0] = -P[0][0]*P_new_item15 - P[0][1]*P_new_item16 - P[0][2]*P_new_item17 + P[0][5];
+    P_new[0][1] = -P[0][1]*P_new_item2 - P[1][1]*P_new_item0 - P[1][2]*P_new_item1;
+    P_new[1][1] = -P[0][1]*P_new_item3 - P[1][1]*P_new_item5 - P[1][2]*P_new_item4;
+    P_new[2][1] = -P[0][1]*P_new_item6 - P[1][1]*P_new_item7 - P[1][2]*P_new_item8;
+    P_new[3][1] = -P[0][1]*P_new_item9 - P[1][1]*P_new_item10 - P[1][2]*P_new_item11 + P[1][3];
+    P_new[4][1] = -P[0][1]*P_new_item12 - P[1][1]*P_new_item13 - P[1][2]*P_new_item14 + P[1][4];
+    P_new[5][1] = -P[0][1]*P_new_item15 - P[1][1]*P_new_item16 - P[1][2]*P_new_item17 + P[1][5];
+    P_new[0][2] = -P[0][2]*P_new_item2 - P[1][2]*P_new_item0 - P[2][2]*P_new_item1;
+    P_new[1][2] = -P[0][2]*P_new_item3 - P[1][2]*P_new_item5 - P[2][2]*P_new_item4;
+    P_new[2][2] = -P[0][2]*P_new_item6 - P[1][2]*P_new_item7 - P[2][2]*P_new_item8;
+    P_new[3][2] = -P[0][2]*P_new_item9 - P[1][2]*P_new_item10 - P[2][2]*P_new_item11 + P[2][3];
+    P_new[4][2] = -P[0][2]*P_new_item12 - P[1][2]*P_new_item13 - P[2][2]*P_new_item14 + P[2][4];
+    P_new[5][2] = -P[0][2]*P_new_item15 - P[1][2]*P_new_item16 - P[2][2]*P_new_item17 + P[2][5];
+    P_new[0][3] = -P[0][3]*P_new_item2 - P[1][3]*P_new_item0 - P[2][3]*P_new_item1;
+    P_new[1][3] = -P[0][3]*P_new_item3 - P[1][3]*P_new_item5 - P[2][3]*P_new_item4;
+    P_new[2][3] = -P[0][3]*P_new_item6 - P[1][3]*P_new_item7 - P[2][3]*P_new_item8;
+    P_new[3][3] = -P[0][3]*P_new_item9 - P[1][3]*P_new_item10 - P[2][3]*P_new_item11 + P[3][3];
+    P_new[4][3] = -P[0][3]*P_new_item12 - P[1][3]*P_new_item13 - P[2][3]*P_new_item14 + P[3][4];
+    P_new[5][3] = -P[0][3]*P_new_item15 - P[1][3]*P_new_item16 - P[2][3]*P_new_item17 + P[3][5];
+    P_new[0][4] = -P[0][4]*P_new_item2 - P[1][4]*P_new_item0 - P[2][4]*P_new_item1;
+    P_new[1][4] = -P[0][4]*P_new_item3 - P[1][4]*P_new_item5 - P[2][4]*P_new_item4;
+    P_new[2][4] = -P[0][4]*P_new_item6 - P[1][4]*P_new_item7 - P[2][4]*P_new_item8;
+    P_new[3][4] = -P[0][4]*P_new_item9 - P[1][4]*P_new_item10 - P[2][4]*P_new_item11 + P[3][4];
+    P_new[4][4] = -P[0][4]*P_new_item12 - P[1][4]*P_new_item13 - P[2][4]*P_new_item14 + P[4][4];
+    P_new[5][4] = -P[0][4]*P_new_item15 - P[1][4]*P_new_item16 - P[2][4]*P_new_item17 + P[4][5];
+    P_new[0][5] = -P[0][5]*P_new_item2 - P[1][5]*P_new_item0 - P[2][5]*P_new_item1;
+    P_new[1][5] = -P[0][5]*P_new_item3 - P[1][5]*P_new_item5 - P[2][5]*P_new_item4;
+    P_new[2][5] = -P[0][5]*P_new_item6 - P[1][5]*P_new_item7 - P[2][5]*P_new_item8;
+    P_new[3][5] = -P[0][5]*P_new_item9 - P[1][5]*P_new_item10 - P[2][5]*P_new_item11 + P[3][5];
+    P_new[4][5] = -P[0][5]*P_new_item12 - P[1][5]*P_new_item13 - P[2][5]*P_new_item14 + P[4][5];
+    P_new[5][5] = -P[0][5]*P_new_item15 - P[1][5]*P_new_item16 - P[2][5]*P_new_item17 + P[5][5];
+
+
+    Vector3f x = {X_new[3], X_new[4], X_new[5]};
+    dcm.transpose();
+    Vector3f x_ = dcm*x;
+    X_new[3] = x_.x;
+    X_new[4] = x_.y;
+    X_new[5] = x_.z;
+    
+    memcpy(X, X_new, sizeof(X));
+    memcpy(P, P_new, sizeof(P));
+}
diff --git a/libraries/AP_NavEKF2/AP_NavJKF.h b/libraries/AP_NavEKF2/AP_NavJKF.h
new file mode 100644
index 0000000..e30be3b
--- /dev/null
+++ b/libraries/AP_NavEKF2/AP_NavJKF.h
@@ -0,0 +1,30 @@
+#pragma once
+
+#include <AP_Math/matrixN.h>
+#include <AP_Math/AP_Math.h>
+#include <AP_AHRS/AP_AHRS.h>
+
+class AP_NavJKF {
+public:
+    AP_NavJKF(const AP_AHRS *ahrs);
+    ~AP_NavJKF();
+
+    void sys_init();
+    // calculate the NED earth spin vector in rad/sec
+    void calcEarthRateNED(Vector3f &omega, int32_t latitude) const;
+    void sys_predict(float delta_t, Vector3f &acc, Matrix3f &dcm);
+    void sys_update(Vector3f &gps, Matrix3f &dcm);
+    void getVelocity(Vector3f &vel){
+        vel.x = X[0];
+        vel.y = X[1];
+        vel.z = X[2];
+    }
+    
+private:
+    float X[6];
+    float P[6][6];
+    float Q[6][6];
+    float R[3][3];
+
+    const AP_AHRS *_ahrs;
+};
diff --git a/libraries/DataFlash/DataFlash.h b/libraries/DataFlash/DataFlash.h
index a5234bf..0db845e 100644
--- a/libraries/DataFlash/DataFlash.h
+++ b/libraries/DataFlash/DataFlash.h
@@ -95,6 +95,8 @@ public:
     void Log_Write_Parameter(const char *name, float value);
     void Log_Write_GPS(uint8_t instance, uint64_t time_us=0);
     void Log_Write_RFND(const RangeFinder &rangefinder);
+    void Log_Write_JKF(Vector3f &vel);
+    void Log_Write_JKF_Sensor();
     void Log_Write_IMU();
     void Log_Write_IMUDT(uint64_t time_us, uint8_t imu_mask);
     bool Log_Write_ISBH(uint16_t seqno,
diff --git a/libraries/DataFlash/LogFile.cpp b/libraries/DataFlash/LogFile.cpp
index 9eb006b..c3f0d14 100644
--- a/libraries/DataFlash/LogFile.cpp
+++ b/libraries/DataFlash/LogFile.cpp
@@ -318,6 +318,75 @@ void DataFlash_Class::Log_Write_IMU_instance(const uint64_t time_us, const uint8
     WriteBlock(&pkt, sizeof(pkt));
 }
 
+void DataFlash_Class::Log_Write_JKF_Sensor()
+{
+    uint64_t time_us = AP_HAL::micros64();
+    const AP_InertialSensor &ins = AP::ins();
+    const Vector3f &gyro = ins.get_gyro();
+    const Vector3f &accel = ins.get_accel();
+
+    const AP_GPS &gps = AP::gps();
+
+    AP_AHRS &ahrs = AP::ahrs();
+
+    Quaternion quat;
+    ahrs.get_secondary_quaternion(quat);
+    struct log_JKF_Sensor pkt = {
+        LOG_PACKET_HEADER_INIT(LOG_JKFS_MSG),
+        time_us : time_us,
+#if 0
+        gyro_x  : gyro.x,
+        gyro_y  : gyro.y,
+        gyro_z  : gyro.z,
+#endif
+        accel_x : accel.x,
+        accel_y : accel.y,
+        accel_z : accel.z,
+             q1 : quat.q1,
+             q2 : quat.q2,
+             q3 : quat.q3,
+             q4 : quat.q4,
+    AHRS_gSpeed : ahrs.groundspeed(),
+     GPS_gSpeed : gps.ground_speed(),
+     GPS_xSpeed : gps.velocity().x,
+     GPS_ySpeed : gps.velocity().y,
+     GPS_zSpeed : gps.velocity().z,
+       latitude : gps.location().lat,
+      longitude : gps.location().lng,
+       altitude : gps.location().alt,
+    };
+    WriteBlock(&pkt, sizeof(pkt));
+}
+
+void DataFlash_Class::Log_Write_JKF(Vector3f &vel)
+{
+    uint64_t time_us = AP_HAL::micros64();
+
+    const AP_GPS &gps = AP::gps();
+
+    AP_AHRS &ahrs = AP::ahrs();
+
+    float jkf_gspeed = sqrt(vel.x*vel.x + vel.y*vel.y);
+    struct log_JKF pkt = {
+        LOG_PACKET_HEADER_INIT(LOG_JKF_MSG),
+        time_us : time_us,
+         gSpeed : jkf_gspeed,
+         xSpeed : vel.x,
+         ySpeed : vel.y,
+         zSpeed : vel.z,
+    AHRS_gSpeed : ahrs.groundspeed(),
+     GPS_gSpeed : gps.ground_speed(),
+     GPS_xSpeed : gps.velocity().x,
+     GPS_ySpeed : gps.velocity().y,
+     GPS_zSpeed : gps.velocity().z,
+       latitude : gps.location().lat,
+      longitude : gps.location().lng,
+       altitude : gps.location().alt,
+    };
+    WriteBlock(&pkt, sizeof(pkt));
+}
+
+
 // Write an raw accel/gyro data packet
 void DataFlash_Class::Log_Write_IMU()
 {
diff --git a/libraries/DataFlash/LogStructure.h b/libraries/DataFlash/LogStructure.h
index 7f2a388..a0e00af 100644
--- a/libraries/DataFlash/LogStructure.h
+++ b/libraries/DataFlash/LogStructure.h
@@ -104,7 +104,7 @@ const struct UnitStructure log_Units[] = {
     { 's', "s" },             // seconds
     { 'q', "rpm" },           // rounds per minute. Not SI, but sometimes more intuitive than Hertz
     { 'r', "rad" },           // radians
-    { 'U', "deglongitude" },  // degrees of longitude
+    { 'X', "deglongitude" },  // degrees of longitude
     { 'u', "ppm" },           // pulses per minute
     { 'U', "us" },            // pulse width modulation in microseconds
     { 'v', "V" },             // Volt
@@ -193,6 +193,30 @@ struct PACKED log_Message {
     char msg[64];
 };
 
+struct PACKED log_JKF_Sensor {
+    LOG_PACKET_HEADER;
+    uint64_t time_us;
+#if 0
+    float gyro_x, gyro_y, gyro_z;
+#endif
+    float accel_x, accel_y, accel_z;
+    float q1, q2, q3, q4;
+    float AHRS_gSpeed, GPS_gSpeed, GPS_xSpeed, GPS_ySpeed, GPS_zSpeed;
+    int32_t  latitude;
+    int32_t  longitude;
+    int32_t  altitude;
+};
+
+struct PACKED log_JKF {
+    LOG_PACKET_HEADER;
+    uint64_t time_us;
+    float gSpeed, xSpeed, ySpeed, zSpeed;
+    float AHRS_gSpeed, GPS_gSpeed, GPS_xSpeed, GPS_ySpeed, GPS_zSpeed;
+    int32_t  latitude;
+    int32_t  longitude;
+    int32_t  altitude;
+};
+
 struct PACKED log_IMU {
     LOG_PACKET_HEADER;
     uint64_t time_us;
@@ -1117,6 +1141,16 @@ struct PACKED log_DSTL {
 #define ISBD_UNITS  "s--ooo"
 #define ISBD_MULTS  "F--???"
 
+#define JKFS_LABELS "TimeUS,AccX,AccY,AccZ,Q1,Q2,Q3,Q4,AS,GS,VX,VY,VZ,Lat,Lng,Alt"
+#define JKFS_FMT   "QffffffffffffLLe"
+#define JKFS_UNITS "sooo----nnnnnDXm"
+#define JKFS_MULTS "F000000000000GGB"
+
+#define JKF_LABELS "TimeUS,gS,xS,yS,zS,AgS,GgS,GxS,GyS,GzS,Lat,Lng,Alt"
+#define JKF_FMT   "QfffffffffLLe"
+#define JKF_UNITS "snnnnnnnnnDXm"
+#define JKF_MULTS "F000000000GGB"
+
 #define IMU_LABELS "TimeUS,GyrX,GyrY,GyrZ,AccX,AccY,AccZ,EG,EA,T,GH,AH,GHz,AHz"
 #define IMU_FMT   "QffffffIIfBBHH"
 #define IMU_UNITS "sEEEooo--O--zz"
@@ -1200,6 +1234,10 @@ Format characters in the format string for binary log messages
       "GPA2", GPA_FMT, GPA_LABELS, GPA_UNITS, GPA_MULTS }, \
     { LOG_GPAB_MSG, sizeof(log_GPA), \
       "GPAB", GPA_FMT, GPA_LABELS, GPA_UNITS, GPA_MULTS }, \
+    { LOG_JKFS_MSG, sizeof(log_JKF_Sensor), \
+      "JKFS",  JKFS_FMT,     JKFS_LABELS, JKFS_UNITS, JKFS_MULTS }, \
+    { LOG_JKF_MSG, sizeof(log_JKF), \
+      "JKF",  JKF_FMT,     JKF_LABELS, JKF_UNITS, JKF_MULTS }, \
     { LOG_IMU_MSG, sizeof(log_IMU), \
       "IMU",  IMU_FMT,     IMU_LABELS, IMU_UNITS, IMU_MULTS }, \
     { LOG_MESSAGE_MSG, sizeof(log_Message), \
@@ -1463,6 +1501,8 @@ enum LogMessages : uint8_t {
     LOG_GPS_MSG,
     LOG_GPS2_MSG,
     LOG_GPSB_MSG,
+    LOG_JKFS_MSG,
+    LOG_JKF_MSG,
     LOG_IMU_MSG,
     LOG_MESSAGE_MSG,
     LOG_RCIN_MSG,
-- 
2.7.4

